from django.shortcuts import render

# for testing
from django.http import HttpResponse

# imports util.py that was provided to us
from . import util

# converts entries/*.md files to html
import markdown2

# regular expression module [NOT USED]
import re

# module for picking a random Wiki entry
import random

# defines functionS that render .html templates from encyclopedia/ 
#* requires arugment 'request' calls the 'name' from urls.py?
#* returns function 'render'
#* render takes request argument and renders the template argument
#* render can provide context argument {} to the template
#? {} is a dict of values, not sure how it is populated
#? dict key can be anything and can be called in html
#? dict value can be a Python variable or function, e.g. a function from util.py

# Index route
def index(request):
    return render(request, "encyclopedia/index.html", {
        # creates a dict where the key "entries" can be called in html and
        # where the single value is a list of entries generated by the list.entries function
        "entries": util.list_entries()
    })

# Gets a wiki entry
def wiki(request, title):
    entry = util.get_entry(title)
    if entry:
        formatted_entry = markdown2.markdown(entry)
        return render(request, "encyclopedia/wiki.html", {
            "title1": title, "entry1": formatted_entry
        })
    else:
        return render(request, "encyclopedia/no_entry.html")

# Returns search results
def search(request):
    title1 = request.POST.get('q')
    entry = util.get_entry(title1)
    if entry:
        entry1 = markdown2.markdown(entry)
        # return HttpResponse(f"{title} / {entry} / {entry1}")
        return render(request, "encyclopedia/wiki.html", {
            "title1": title1, "entry1": entry1
        })
    else: 
        entries = util.list_entries()
        results = []
        # return HttpResponse(f"{entries} / {len(entries)} / {len(entries[0])}")
        for i in range(len(entries)):
            if (title1 in entries[i]) or (title1.capitalize() in entries[i]) or (title1.casefold() in entries[i]):
                results.append(entries[i])
                #return HttpResponse(f"{title1} / {entries1[i]} / {results}")
    return render(request, "encyclopedia/search.html", {
        "results": results
    })

# Allows a user to type out a new Wiki entry
def wiki_new(request):
    return render(request, "encyclopedia/wiki_new.html")

# Saves a new or edited Wiki entry
def wiki_save(request):
    title1 = request.POST.get('title1')
    entry1 = request.POST.get('entry1')
    wiki_action = request.POST.get('wiki_action')
    entries = util.list_entries()
    # return HttpResponse(f"{wiki_action} / {entries}")
    if wiki_action:
        for i in range(len(entries)):
            if (title1 in entries[i]) or (title1.capitalize() in entries[i]) or (title1.casefold() in entries[i]):
                return render(request, "encyclopedia/dup_entry.html", {
                    "title1": title1, "entry1": entry1
                    })
    else:
        util.save_entry(title1, entry1)
        return render(request, "encyclopedia/wiki_save.html", {
            "title1": title1, "entry1": entry1
        })

# # Saves a new or edited Wiki entry [BACKUP]
# def wiki_save(request):
#     title1 = request.POST.get('title1')
#     entry1 = request.POST.get('entry1')
#     util.save_entry(title1, entry1)
#     return render(request, "encyclopedia/wiki_save.html", {
#         "title1": title1, "entry1": entry1
#     })

# Allows a user to edit a Wiki entry
def wiki_edit(request):
    title1 = request.POST.get('title1')
    entry1 = str(util.get_entry(title1))
    entry2 = entry1.replace('\r\n', '\n')
    return render(request, "encyclopedia/wiki_edit.html", {
        "title1": title1, "entry1": entry2
    })

# Provides a random Wiki entry
def wiki_random(request):
    entries = util.list_entries()
    pick = random.choice(entries)
    entry = util.get_entry(pick)
    formatted_entry = markdown2.markdown(entry)
    return render(request, "encyclopedia/wiki.html", {
        "title1": pick, "entry1": formatted_entry
    })
